#!/usr/bin/env python3
"""
KV Cache C++ Packer
自动拉取、编译、安装脚本，用于构建所有依赖包
"""

import os
import sys
import subprocess
import json
import shutil
import logging
import glob
from pathlib import Path
from typing import Dict, List
from concurrent.futures import ThreadPoolExecutor, as_completed

# 包配置
PACKS = {
    "https://github.com/AI-Infra-Team/etcd-cpp-apiv3": {
        "branch": "master",
        "c++": 17,
        "build_type": "Release",
        "define": [
            ["BUILD_STATIC_LIBS", "ON"],
            ["BUILD_SHARED_LIBS", "OFF"],
        ],
    },
    "https://github.com/AI-Infra-Team/gflags": {
        "branch": "master",
        "c++": 17,
        "build_type": "Release",
        "define": [
            ["BUILD_SHARED_LIBS", "OFF"],
            ["BUILD_STATIC_LIBS", "ON"],
            ["BUILD_gflags_LIB", "ON"],
        ],
    },
    "https://github.com/AI-Infra-Team/glog": {
        "branch": "v0.6.0",
        "c++": 17,
        "dependencies": ["gflags"],
        "build_type": "Release",
        "define": [
            ["WITH_GFLAGS", "ON"],
            ["BUILD_SHARED_LIBS", "OFF"],
            ["BUILD_STATIC_LIBS", "ON"],
        ],
    },
    # "https://github.com/AI-Infra-Team/googletest": {
    #     "branch": "main",
    # },
    "https://github.com/AI-Infra-Team/jsoncpp": {
        "branch": "master",
        "c++": 17,
        "define": [
            ["BUILD_SHARED_LIBS", "OFF"],
            ["BUILD_STATIC_LIBS", "ON"],
            ["BUILD_OBJECT_LIBS", "OFF"],
            ["CMAKE_BUILD_TYPE", "Release"],
        ],
    },
    "https://github.com/AI-Infra-Team/rdma-core": {
        "branch": "master",
        "c++": 17,
        "define": [
            ["NO_PYVERBS", "ON"],
            ["BUILD_SHARED_LIBS", "ON"],
            ["BUILD_STATIC_LIBS", "OFF"],
            ["BUILD_TESTING", "OFF"],
            ["BUILD_EXAMPLES", "OFF"],
            ["BUILD_EXAMPLES", "OFF"],
            ["NO_MAN_PAGES", "ON"],
        ],
    },
    "https://github.com/AI-Infra-Team/yalantinglibs": {
        "branch": "main",
        "c++": 20,
        "dependencies": ["rdma-core"],
        "define": [
            ["GENERATE_BENCHMARK_DATA", "OFF"],
            ["BUILD_EXAMPLES", "OFF"],
            ["BUILD_BENCHMARK", "OFF"],
            ["BUILD_TESTING", "OFF"],
            ["COVERAGE_TEST", "OFF"],
            ["BUILD_UNIT_TESTS", "OFF"],
        ],
    },
}
APT = [
    # 基础构建工具
    "build-essential",
    "cmake",
    "git",
    "pkg-config",
    "autoconf",
    "automake",
    "libtool",
    "wget",
    "curl",
    "python3",
    "python3-pip",
    # 开发库
    "libssl-dev",
    "zlib1g-dev",
    "ca-certificates",
    # 项目特定依赖
    "libprotobuf-dev",
    "protobuf-compiler-grpc",
    "libgrpc++-dev",
    "libgrpc-dev",
    "libunwind-dev",
    "gcc-10",
    "g++-10",
    "libcpprest-dev",
    "libnl-3-dev",
    "libnl-route-3-dev",
]
DYNAMIC_COPY = [
    # "*grpc*.so*",
    # "*protobuf*.so*",
    "*unwind*.so*",
    "libssl.so.1.1",
    "libcrypto.so.1.1",
    "libprotobuf.so.17.0.0",
]
DYNAMIC_COPY_RENAME = {
    "libgrpc++.so.1.16.1": "libgrpc++.so",
    "libgrpc.so.6.0.0": "libgrpc.so",
    "libssl.so.1.1": "libssl.so",
    "libcrypto.so.1.1": "libcrypto.so",
    "libprotobuf.so.17.0.0": "libprotobuf.so",
}
CREATE_LIB_CMAKE_CONFIG = {
    "grpc++": """# Generated by kvcache_cxx_packer
# gRPC CMake Configuration File

# Compute the installation prefix relative to this file
get_filename_component(_IMPORT_PREFIX "${CMAKE_CURRENT_LIST_FILE}" PATH)
get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
if(_IMPORT_PREFIX STREQUAL "/")
  set(_IMPORT_PREFIX "")
endif()

# Set the include directories
set(gRPC_INCLUDE_DIRS "${_IMPORT_PREFIX}/include")

# Set the library directories
set(gRPC_LIBRARY_DIRS "${_IMPORT_PREFIX}/lib")

# Find the libraries using relative paths
find_library(gRPC_LIBRARY NAMES grpc PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(gRPC_CPP_LIBRARY NAMES grpc++ PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(gRPC_UNSECURE_LIBRARY NAMES grpc_unsecure PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(gRPC_CPP_UNSECURE_LIBRARY NAMES grpc++_unsecure PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)

# Find protobuf
find_library(PROTOBUF_LIBRARY NAMES protobuf PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(PROTOC_LIBRARY NAMES protoc PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)

# Find additional dependencies
find_library(CARES_LIBRARY NAMES cares PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(ADDRESS_SORTING_LIBRARY NAMES address_sorting PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(RE2_LIBRARY NAMES re2 PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(UPB_LIBRARY NAMES upb PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(ABSL_BASE_LIBRARY NAMES absl_base PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(ABSL_STRINGS_LIBRARY NAMES absl_strings PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)

# Set the found variables
set(gRPC_FOUND TRUE)
set(gRPC_LIBRARIES ${gRPC_LIBRARY} ${gRPC_CPP_LIBRARY})

# Create imported targets
if(NOT TARGET gRPC::grpc)
    add_library(gRPC::grpc SHARED IMPORTED)
    set_target_properties(gRPC::grpc PROPERTIES
        IMPORTED_LOCATION "${gRPC_LIBRARY}"
        INTERFACE_INCLUDE_DIRECTORIES "${gRPC_INCLUDE_DIRS}"
    )
endif()

if(NOT TARGET gRPC::grpc++)
    add_library(gRPC::grpc++ SHARED IMPORTED)
    set_target_properties(gRPC::grpc++ PROPERTIES
        IMPORTED_LOCATION "${gRPC_CPP_LIBRARY}"
        INTERFACE_INCLUDE_DIRECTORIES "${gRPC_INCLUDE_DIRS}"
        INTERFACE_LINK_LIBRARIES "gRPC::grpc"
    )
endif()

if(gRPC_UNSECURE_LIBRARY AND NOT TARGET gRPC::grpc_unsecure)
    add_library(gRPC::grpc_unsecure SHARED IMPORTED)
    set_target_properties(gRPC::grpc_unsecure PROPERTIES
        IMPORTED_LOCATION "${gRPC_UNSECURE_LIBRARY}"
        INTERFACE_INCLUDE_DIRECTORIES "${gRPC_INCLUDE_DIRS}"
    )
endif()

if(gRPC_CPP_UNSECURE_LIBRARY AND NOT TARGET gRPC::grpc++_unsecure)
    add_library(gRPC::grpc++_unsecure SHARED IMPORTED)
    set_target_properties(gRPC::grpc++_unsecure PROPERTIES
        IMPORTED_LOCATION "${gRPC_CPP_UNSECURE_LIBRARY}"
        INTERFACE_INCLUDE_DIRECTORIES "${gRPC_INCLUDE_DIRS}"
        INTERFACE_LINK_LIBRARIES "gRPC::grpc_unsecure"
    )
endif()

# Set variables for compatibility
set(GRPC_INCLUDE_DIRS ${gRPC_INCLUDE_DIRS})
set(GRPC_LIBRARIES ${gRPC_LIBRARIES})
set(GRPC_FOUND ${gRPC_FOUND})

# Set the grpc_DIR for find_package
set(grpc_DIR "${_IMPORT_PREFIX}/lib/cmake/grpc")
set(gRPC_DIR "${_IMPORT_PREFIX}/lib/cmake/grpc")

# Clean up
set(_IMPORT_PREFIX)
""",
    "gRPC": """# Generated by kvcache_cxx_packer
# gRPC CMake Configuration File (Alternative naming)

# Compute the installation prefix relative to this file
get_filename_component(_IMPORT_PREFIX "${CMAKE_CURRENT_LIST_FILE}" PATH)
get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
if(_IMPORT_PREFIX STREQUAL "/")
  set(_IMPORT_PREFIX "")
endif()

# Set the include directories
set(gRPC_INCLUDE_DIRS "${_IMPORT_PREFIX}/include")
set(GRPC_INCLUDE_DIRS "${_IMPORT_PREFIX}/include")

# Set the library directories
set(gRPC_LIBRARY_DIRS "${_IMPORT_PREFIX}/lib")
set(GRPC_LIBRARY_DIRS "${_IMPORT_PREFIX}/lib")

# Find the libraries using relative paths
find_library(gRPC_LIBRARY NAMES grpc PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(gRPC_CPP_LIBRARY NAMES grpc++ PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(gRPC_UNSECURE_LIBRARY NAMES grpc_unsecure PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(gRPC_CPP_UNSECURE_LIBRARY NAMES grpc++_unsecure PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)

# Find protobuf
find_library(PROTOBUF_LIBRARY NAMES protobuf PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(PROTOC_LIBRARY NAMES protoc PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)

# Find additional dependencies
find_library(CARES_LIBRARY NAMES cares PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(ADDRESS_SORTING_LIBRARY NAMES address_sorting PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(RE2_LIBRARY NAMES re2 PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(UPB_LIBRARY NAMES upb PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(ABSL_BASE_LIBRARY NAMES absl_base PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(ABSL_STRINGS_LIBRARY NAMES absl_strings PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)

# Set the found variables (both gRPC_ and GRPC_ prefixes for compatibility)
set(gRPC_FOUND TRUE)
set(GRPC_FOUND TRUE)
set(gRPC_LIBRARIES ${gRPC_LIBRARY} ${gRPC_CPP_LIBRARY})
set(GRPC_LIBRARIES ${gRPC_LIBRARY} ${gRPC_CPP_LIBRARY})

# Create imported targets
if(NOT TARGET gRPC::grpc)
    add_library(gRPC::grpc SHARED IMPORTED)
    set_target_properties(gRPC::grpc PROPERTIES
        IMPORTED_LOCATION "${gRPC_LIBRARY}"
        INTERFACE_INCLUDE_DIRECTORIES "${gRPC_INCLUDE_DIRS}"
    )
endif()

if(NOT TARGET gRPC::grpc++)
    add_library(gRPC::grpc++ SHARED IMPORTED)
    set_target_properties(gRPC::grpc++ PROPERTIES
        IMPORTED_LOCATION "${gRPC_CPP_LIBRARY}"
        INTERFACE_INCLUDE_DIRECTORIES "${gRPC_INCLUDE_DIRS}"
        INTERFACE_LINK_LIBRARIES "gRPC::grpc"
    )
endif()

if(gRPC_UNSECURE_LIBRARY AND NOT TARGET gRPC::grpc_unsecure)
    add_library(gRPC::grpc_unsecure SHARED IMPORTED)
    set_target_properties(gRPC::grpc_unsecure PROPERTIES
        IMPORTED_LOCATION "${gRPC_UNSECURE_LIBRARY}"
        INTERFACE_INCLUDE_DIRECTORIES "${gRPC_INCLUDE_DIRS}"
    )
endif()

if(gRPC_CPP_UNSECURE_LIBRARY AND NOT TARGET gRPC::grpc++_unsecure)
    add_library(gRPC::grpc++_unsecure SHARED IMPORTED)
    set_target_properties(gRPC::grpc++_unsecure PROPERTIES
        IMPORTED_LOCATION "${gRPC_CPP_UNSECURE_LIBRARY}"
        INTERFACE_INCLUDE_DIRECTORIES "${gRPC_INCLUDE_DIRS}"
        INTERFACE_LINK_LIBRARIES "gRPC::grpc_unsecure"
    )
endif()

# Create additional targets with GRPC:: namespace for compatibility
if(NOT TARGET GRPC::grpc)
    add_library(GRPC::grpc ALIAS gRPC::grpc)
endif()

if(NOT TARGET GRPC::grpc++)
    add_library(GRPC::grpc++ ALIAS gRPC::grpc++)
endif()

# Set directory variables for find_package compatibility
set(gRPC_DIR "${_IMPORT_PREFIX}/lib/cmake/gRPC")
set(GRPC_DIR "${_IMPORT_PREFIX}/lib/cmake/gRPC")
set(grpc_DIR "${_IMPORT_PREFIX}/lib/cmake/gRPC")

# Clean up
set(_IMPORT_PREFIX)
""",
    "Protobuf": """# Generated by kvcache_cxx_packer
# Protobuf CMake Configuration File

# Compute the installation prefix relative to this file
get_filename_component(_IMPORT_PREFIX "${CMAKE_CURRENT_LIST_FILE}" PATH)
get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
if(_IMPORT_PREFIX STREQUAL "/")
  set(_IMPORT_PREFIX "")
endif()

# Set the include directories
set(Protobuf_INCLUDE_DIRS "${_IMPORT_PREFIX}/include")
set(PROTOBUF_INCLUDE_DIRS "${_IMPORT_PREFIX}/include")

# Set the library directories
set(Protobuf_LIBRARY_DIRS "${_IMPORT_PREFIX}/lib")
set(PROTOBUF_LIBRARY_DIRS "${_IMPORT_PREFIX}/lib")

# Find the libraries using relative paths
find_library(Protobuf_LIBRARY NAMES protobuf PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(Protobuf_LITE_LIBRARY NAMES protobuf-lite PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)
find_library(Protoc_LIBRARY NAMES protoc PATHS "${_IMPORT_PREFIX}/lib" NO_DEFAULT_PATH)

# Find the protoc compiler
find_program(Protobuf_PROTOC_EXECUTABLE NAMES protoc PATHS "${_IMPORT_PREFIX}/bin" NO_DEFAULT_PATH)

# Set the found variables (both Protobuf_ and PROTOBUF_ prefixes for compatibility)
set(Protobuf_FOUND TRUE)
set(PROTOBUF_FOUND TRUE)
set(Protobuf_LIBRARIES ${Protobuf_LIBRARY})
set(PROTOBUF_LIBRARIES ${Protobuf_LIBRARY})

if(Protobuf_LITE_LIBRARY)
    list(APPEND Protobuf_LIBRARIES ${Protobuf_LITE_LIBRARY})
    list(APPEND PROTOBUF_LIBRARIES ${Protobuf_LITE_LIBRARY})
endif()

if(Protoc_LIBRARY)
    list(APPEND Protobuf_LIBRARIES ${Protoc_LIBRARY})
    list(APPEND PROTOBUF_LIBRARIES ${Protoc_LIBRARY})
endif()

# Set protoc executable
set(Protobuf_PROTOC_EXECUTABLE ${Protobuf_PROTOC_EXECUTABLE})
set(PROTOBUF_PROTOC_EXECUTABLE ${Protobuf_PROTOC_EXECUTABLE})

# Create imported targets
if(NOT TARGET protobuf::protobuf)
    add_library(protobuf::protobuf SHARED IMPORTED)
    set_target_properties(protobuf::protobuf PROPERTIES
        IMPORTED_LOCATION "${Protobuf_LIBRARY}"
        INTERFACE_INCLUDE_DIRECTORIES "${Protobuf_INCLUDE_DIRS}"
    )
endif()

if(Protobuf_LITE_LIBRARY AND NOT TARGET protobuf::protobuf-lite)
    add_library(protobuf::protobuf-lite SHARED IMPORTED)
    set_target_properties(protobuf::protobuf-lite PROPERTIES
        IMPORTED_LOCATION "${Protobuf_LITE_LIBRARY}"
        INTERFACE_INCLUDE_DIRECTORIES "${Protobuf_INCLUDE_DIRS}"
    )
endif()

if(Protoc_LIBRARY AND NOT TARGET protobuf::protoc)
    add_library(protobuf::protoc SHARED IMPORTED)
    set_target_properties(protobuf::protoc PROPERTIES
        IMPORTED_LOCATION "${Protoc_LIBRARY}"
        INTERFACE_INCLUDE_DIRECTORIES "${Protobuf_INCLUDE_DIRS}"
    )
endif()

# Create legacy targets for compatibility
if(NOT TARGET protobuf::libprotobuf)
    add_library(protobuf::libprotobuf ALIAS protobuf::protobuf)
endif()

if(Protobuf_LITE_LIBRARY AND NOT TARGET protobuf::libprotobuf-lite)
    add_library(protobuf::libprotobuf-lite ALIAS protobuf::protobuf-lite)
endif()

if(Protoc_LIBRARY AND NOT TARGET protobuf::libprotoc)
    add_library(protobuf::libprotoc ALIAS protobuf::protoc)
endif()

# Set directory variables for find_package compatibility
set(Protobuf_DIR "${_IMPORT_PREFIX}/lib/cmake/protobuf")
set(PROTOBUF_DIR "${_IMPORT_PREFIX}/lib/cmake/protobuf")
set(protobuf_DIR "${_IMPORT_PREFIX}/lib/cmake/protobuf")

# Clean up
set(_IMPORT_PREFIX)
""",
}
CPU_COUNT = 4  # os.cpu_count() or 4

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.FileHandler("build.log"), logging.StreamHandler(sys.stdout)],
)
logger = logging.getLogger(__name__)


class Builder:
    def __init__(self, install_prefix="output", build_dir="build", output_logs_dir="output_logs", max_workers=4):
        self.install_prefix = install_prefix
        self.build_dir = Path(build_dir)
        self.build_dir.mkdir(exist_ok=True)
        self.output_logs_dir = Path(output_logs_dir)
        self.output_logs_dir.mkdir(exist_ok=True)
        self.max_workers = max_workers
        self.build_results = {}
        self.built_packages = set()  # 跟踪已构建的包

    def get_package_name(self, url: str) -> str:
        """从URL获取包名"""
        return url.split("/")[-1]

    def resolve_dependencies(self, packages: Dict) -> List[str]:
        """解析依赖关系，返回按依赖顺序排列的URL列表"""
        visited = set()
        temp_visited = set()
        result = []

        def visit(url: str):
            if url in temp_visited:
                raise ValueError(f"Circular dependency detected involving {url}")
            if url in visited:
                return

            temp_visited.add(url)

            # 处理依赖
            config = packages.get(url, {})
            dependencies = config.get("dependencies", [])

            for dep_name in dependencies:
                # 查找依赖的URL
                dep_url = None
                for pkg_url in packages:
                    if self.get_package_name(pkg_url) == dep_name:
                        dep_url = pkg_url
                        break

                if dep_url:
                    visit(dep_url)
                else:
                    logger.warning(
                        f"Dependency {dep_name} not found for {self.get_package_name(url)}"
                    )

            temp_visited.remove(url)
            visited.add(url)
            result.append(url)

        for url in packages:
            visit(url)

        return result

    def generate_cmake_args(self, config: Dict) -> str:
        """生成CMake配置参数"""
        args = []

        # 编译器设置
        if "CC" in os.environ:
            args.append(f"-DCMAKE_C_COMPILER={os.environ['CC']}")
        if "CXX" in os.environ:
            args.append(f"-DCMAKE_CXX_COMPILER={os.environ['CXX']}")

        # 基础参数
        build_type = config.get("build_type", "Release")
        args.append(f"-DCMAKE_BUILD_TYPE={build_type}")
        args.append(f"-DCMAKE_INSTALL_PREFIX={self.install_prefix}")

        # 获取C++标准
        cpp_std = config.get("c++")

        # 依赖包路径 - 使用更直接的方式
        dependencies = config.get("dependencies", [])
        if dependencies:
            # 添加PREFIX_PATH以帮助查找已安装的依赖包
            args.append(f"-DCMAKE_PREFIX_PATH={self.install_prefix}")

            # 直接在编译和链接标志中添加路径
            cxx_flags = f"-I{self.install_prefix}/include"
            linker_flags = f"-L{self.install_prefix}/lib"

            # 如果有C++标准要求，添加到CXX_FLAGS中
            if cpp_std:
                cxx_flags = f"-std=c++{cpp_std} {cxx_flags}"

            args.append(f"-DCMAKE_CXX_FLAGS='{cxx_flags}'")
            args.append(f"-DCMAKE_EXE_LINKER_FLAGS='{linker_flags}'")
            args.append(f"-DCMAKE_SHARED_LINKER_FLAGS='{linker_flags}'")

            # 为每个依赖设置特定的路径变量
            for dep_name in dependencies:
                if dep_name in self.built_packages:
                    # 设置依赖包的查找路径
                    args.append(f"-D{dep_name}_DIR={self.install_prefix}")
                    args.append(f"-D{dep_name}_ROOT={self.install_prefix}")
                    # 也尝试小写版本
                    args.append(f"-D{dep_name.lower()}_DIR={self.install_prefix}")
                    args.append(f"-D{dep_name.lower()}_ROOT={self.install_prefix}")

            # 添加pkg-config路径
            pkgconfig_path = f"{self.install_prefix}/lib/pkgconfig"
            if os.path.exists(pkgconfig_path):
                current_pkg_config = os.environ.get("PKG_CONFIG_PATH", "")
                if pkgconfig_path not in current_pkg_config:
                    if current_pkg_config:
                        os.environ["PKG_CONFIG_PATH"] = (
                            f"{current_pkg_config}:{pkgconfig_path}"
                        )
                    else:
                        os.environ["PKG_CONFIG_PATH"] = pkgconfig_path
        else:
            # 没有依赖时，正常设置C++标准
            if cpp_std:
                args.append(f"-DCMAKE_CXX_STANDARD={cpp_std}")
                args.append("-DCMAKE_CXX_STANDARD_REQUIRED=ON")

        # 自定义定义
        defines = config.get("define", [])
        for define in defines:
            if isinstance(define, list) and len(define) == 2:
                key, value = define
                args.append(f"-D{key}={value}")
            elif isinstance(define, str):
                args.append(f"-D{define}")

        # 默认关闭测试
        if not any("BUILD_TESTING" in str(define) for define in defines):
            args.append("-DBUILD_TESTING=OFF")

        return " \\\n    ".join(args)

    def run_command(self, cmd: str, cwd: str = None, check: bool = True) -> int:
        """执行shell命令"""
        logger.info(f"Running command: {cmd}")
        if cwd:
            logger.info(f"Working directory: {cwd}")
            # 切换到指定目录执行命令
            original_cwd = os.getcwd()
            os.chdir(cwd)
            try:
                result = os.system(cmd)
            finally:
                os.chdir(original_cwd)
        else:
            result = os.system(cmd)

        if check and result != 0:
            raise subprocess.CalledProcessError(result, cmd)

        return result

    def install_apt_packages(self):
        """安装APT包"""
        logger.info("Installing APT packages...")

        # 更新包列表
        self.run_command("apt-get update")

        # 直接使用APT数组中的所有包
        cmd = f"apt-get install -y {' '.join(APT)}"
        self.run_command(cmd)

        logger.info("APT packages installed successfully")

    def clone_repository(self, url: str, branch: str, target_dir: Path) -> bool:
        """克隆Git仓库"""
        try:
            if target_dir.exists():
                logger.info(
                    f"Directory {target_dir} already exists, pulling latest changes..."
                )
                self.run_command("git pull", cwd=str(target_dir))
            else:
                logger.info(f"Cloning {url} (branch: {branch}) to {target_dir}")
                self.run_command(f"git clone -b {branch} {url} {target_dir}")
            return True
        except Exception as e:
            logger.error(f"Failed to clone {url}: {e}")
            return False

    def build_cmake_project(
        self, source_dir: Path, package_name: str, config: Dict
    ) -> bool:
        """构建CMake项目"""
        try:
            build_dir = source_dir / "build"
            build_dir.mkdir(exist_ok=True)

            # 生成CMake配置参数
            cmake_args = self.generate_cmake_args(config)
            cmake_cmd = f"cmake .. \\\n    {cmake_args}"

            self.run_command(cmake_cmd, cwd=str(build_dir))

            # 编译
            self.run_command(f"make -j{CPU_COUNT}", cwd=str(build_dir))

            # 安装
            self.run_command("make install", cwd=str(build_dir))

            # 标记为已构建
            self.built_packages.add(package_name)

            logger.info(f"Successfully built and installed {package_name}")
            return True

        except Exception as e:
            logger.error(f"Failed to build {package_name}: {e}")
            return False

    def build_autotools_project(
        self, source_dir: Path, package_name: str, config: Dict
    ) -> bool:
        """构建Autotools项目"""
        try:
            # 尝试autogen.sh或autoreconf
            if (source_dir / "autogen.sh").exists():
                self.run_command("./autogen.sh", cwd=str(source_dir))
            elif (source_dir / "configure.ac").exists() or (
                source_dir / "configure.in"
            ).exists():
                self.run_command("autoreconf -fiv", cwd=str(source_dir))

            # 配置
            configure_cmd = f"./configure --prefix={self.install_prefix}"

            # 添加编译器设置
            if "CC" in os.environ:
                configure_cmd += f" CC={os.environ['CC']}"
            if "CXX" in os.environ:
                configure_cmd += f" CXX={os.environ['CXX']}"

            # 处理依赖包路径
            dependencies = config.get("dependencies", [])
            if dependencies:
                # 添加include和lib路径到环境变量
                cppflags = f"-I{self.install_prefix}/include"
                ldflags = f"-L{self.install_prefix}/lib"

                # 检查是否已有这些环境变量
                existing_cppflags = os.environ.get("CPPFLAGS", "")
                existing_ldflags = os.environ.get("LDFLAGS", "")

                if existing_cppflags:
                    cppflags = f"{existing_cppflags} {cppflags}"
                if existing_ldflags:
                    ldflags = f"{existing_ldflags} {ldflags}"

                configure_cmd += f" CPPFLAGS='{cppflags}'"
                configure_cmd += f" LDFLAGS='{ldflags}'"

                # 设置PKG_CONFIG_PATH
                pkgconfig_path = f"{self.install_prefix}/lib/pkgconfig"
                if os.path.exists(pkgconfig_path):
                    current_pkg_config = os.environ.get("PKG_CONFIG_PATH", "")
                    if pkgconfig_path not in current_pkg_config:
                        if current_pkg_config:
                            os.environ["PKG_CONFIG_PATH"] = (
                                f"{current_pkg_config}:{pkgconfig_path}"
                            )
                        else:
                            os.environ["PKG_CONFIG_PATH"] = pkgconfig_path

            # 添加C++标准支持
            cpp_std = config.get("c++")
            if cpp_std:
                cxxflags = f"-std=c++{cpp_std}"
                if "CXXFLAGS" in configure_cmd:
                    configure_cmd = configure_cmd.replace(
                        "CXXFLAGS='", f"CXXFLAGS='{cxxflags} "
                    )
                else:
                    configure_cmd += f" CXXFLAGS='{cxxflags}'"

            self.run_command(configure_cmd, cwd=str(source_dir))

            # 编译和安装
            self.run_command(f"make -j{CPU_COUNT}", cwd=str(source_dir))
            self.run_command("make install", cwd=str(source_dir))

            # 标记为已构建
            self.built_packages.add(package_name)

            logger.info(f"Successfully built and installed {package_name}")
            return True

        except Exception as e:
            logger.error(f"Failed to build {package_name}: {e}")
            return False

    def build_package(self, url: str, config: Dict) -> tuple:
        """构建单个包"""
        package_name = self.get_package_name(url)
        source_dir = self.build_dir / package_name
        branch = config.get("branch", "master")

        logger.info(f"Building package: {package_name}")
        logger.info(f"Configuration: {config}")

        # 克隆仓库
        if not self.clone_repository(url, branch, source_dir):
            return (package_name, False, "Failed to clone repository")

        # 刷新ldconfig
        self.run_command("ldconfig")

        # 尝试不同的构建系统
        if (source_dir / "CMakeLists.txt").exists():
            success = self.build_cmake_project(source_dir, package_name, config)
        elif (source_dir / "configure").exists() or (
            source_dir / "autogen.sh"
        ).exists():
            success = self.build_autotools_project(source_dir, package_name, config)
        else:
            logger.warning(f"Unknown build system for {package_name}, trying CMake...")
            success = self.build_cmake_project(source_dir, package_name, config)

        if success:
            return (package_name, True, "Built successfully")
        else:
            return (package_name, False, "Build failed")

    def setup_compiler_environment(self):
        """设置编译器环境变量"""
        logger.info("Setting up compiler environment...")

        # 查找gcc-10和g++-10
        gcc_10_path = None
        gxx_10_path = None

        # 常见的安装路径
        common_paths = ["/usr/bin", "/usr/local/bin", "/opt/gcc/bin"]

        for path in common_paths:
            gcc_candidate = os.path.join(path, "gcc-10")
            gxx_candidate = os.path.join(path, "g++-10")

            if os.path.exists(gcc_candidate) and os.access(gcc_candidate, os.X_OK):
                gcc_10_path = gcc_candidate
            if os.path.exists(gxx_candidate) and os.access(gxx_candidate, os.X_OK):
                gxx_10_path = gxx_candidate

            if gcc_10_path and gxx_10_path:
                break

        # 设置环境变量
        if gcc_10_path:
            os.environ["CC"] = gcc_10_path
            logger.info(f"Set CC={gcc_10_path}")
        else:
            logger.warning("gcc-10 not found, using system default")

        if gxx_10_path:
            os.environ["CXX"] = gxx_10_path
            logger.info(f"Set CXX={gxx_10_path}")
        else:
            logger.warning("g++-10 not found, using system default")

        # 验证编译器版本
        if gcc_10_path:
            logger.info("Verifying GCC version:")
            os.system(f"{gcc_10_path} --version")

        if gxx_10_path:
            logger.info("Verifying G++ version:")
            os.system(f"{gxx_10_path} --version")

    def _copy_library_file(
        self, src_file, target_name, output_lib_dir, is_rename=False, original_name=None
    ):
        """
        复制单个库文件的统一函数

        Args:
            src_file: 源文件路径
            target_name: 目标文件名
            output_lib_dir: 输出目录
            is_rename: 是否为重命名操作
            original_name: 原始文件名（用于重命名日志）

        Returns:
            tuple: (success: bool, copied_file_path: str or None)
        """
        try:
            src_path = Path(src_file)
            dst_path = output_lib_dir / target_name

            # 如果是符号链接，复制链接指向的实际文件
            if src_path.is_symlink():
                real_src = src_path.resolve()
                if real_src.exists():
                    shutil.copy2(real_src, dst_path)
                    if is_rename:
                        logger.info(
                            f"Copied and renamed symlink target: {real_src} -> {dst_path} (renamed from {original_name})"
                        )
                    else:
                        logger.info(f"Copied symlink target: {real_src} -> {dst_path}")
                    return True, str(dst_path)
            else:
                shutil.copy2(src_file, dst_path)
                if is_rename:
                    logger.info(
                        f"Copied and renamed: {src_file} -> {dst_path} (renamed from {original_name})"
                    )
                else:
                    logger.info(f"Copied: {src_file} -> {dst_path}")
                return True, str(dst_path)

        except Exception as e:
            logger.warning(f"Failed to copy {src_file}: {e}")
            return False, None

    def copy_dynamic_libraries(self):
        """复制系统动态库文件到输出目录"""
        logger.info("Copying dynamic libraries to output directory...")

        # 创建输出lib目录
        output_lib_dir = Path(self.install_prefix) / "lib"
        output_lib_dir.mkdir(parents=True, exist_ok=True)

        # 系统库目录列表
        system_lib_dirs = [
            "/usr/lib",
            "/usr/lib/x86_64-linux-gnu",
            "/usr/lib64",
            "/usr/local/lib",
            "/usr/local/lib64",
            "/lib",
            "/lib/x86_64-linux-gnu",
            "/lib64",
        ]

        copied_files = []
        failed_patterns = []

        # 第一阶段：处理 DYNAMIC_COPY 模式匹配拷贝
        logger.info("Stage 1: Copying files by pattern matching...")
        for pattern in DYNAMIC_COPY:
            found_files = []

            # 在每个系统目录中搜索匹配的文件
            for lib_dir in system_lib_dirs:
                if os.path.exists(lib_dir):
                    search_pattern = os.path.join(lib_dir, pattern)
                    matches = glob.glob(search_pattern)
                    found_files.extend(matches)

            if found_files:
                logger.info(
                    f"Found {len(found_files)} files matching pattern '{pattern}'"
                )

                for src_file in found_files:
                    src_path = Path(src_file)
                    target_name = src_path.name  # 不重命名，使用原文件名

                    success, copied_path = self._copy_library_file(
                        src_file, target_name, output_lib_dir, is_rename=False
                    )

                    if success and copied_path:
                        copied_files.append(copied_path)
            else:
                logger.warning(f"No files found matching pattern '{pattern}'")
                failed_patterns.append(pattern)

        # 第二阶段：处理 DYNAMIC_COPY_RENAME 精确查找和重命名
        logger.info("Stage 2: Copying and renaming specific files...")
        failed_renames = []

        for original_name, target_name in DYNAMIC_COPY_RENAME.items():
            found_src = None

            # 在系统目录中查找原始文件名
            for lib_dir in system_lib_dirs:
                if os.path.exists(lib_dir):
                    candidate_path = os.path.join(lib_dir, original_name)
                    if os.path.exists(candidate_path):
                        found_src = candidate_path
                        break

            if found_src:
                success, copied_path = self._copy_library_file(
                    found_src,
                    target_name,
                    output_lib_dir,
                    is_rename=True,
                    original_name=original_name,
                )

                if success and copied_path:
                    copied_files.append(copied_path)
                else:
                    failed_renames.append(original_name)
            else:
                logger.warning(f"File not found for renaming: {original_name}")
                failed_renames.append(original_name)

        # 更新动态链接器缓存
        if copied_files:
            logger.info(
                f"Successfully copied {len(copied_files)} dynamic library files"
            )
            # 添加输出lib目录到LD_LIBRARY_PATH
            current_ld_path = os.environ.get("LD_LIBRARY_PATH", "")
            new_ld_path = str(output_lib_dir)
            if current_ld_path:
                os.environ["LD_LIBRARY_PATH"] = f"{new_ld_path}:{current_ld_path}"
            else:
                os.environ["LD_LIBRARY_PATH"] = new_ld_path

            # 更新ldconfig缓存
            try:
                self.run_command("ldconfig")
            except:
                logger.warning("Failed to update ldconfig cache")

        # 报告失败的情况
        if failed_patterns:
            logger.warning(f"Failed to find files for patterns: {failed_patterns}")
        if failed_renames:
            logger.warning(f"Failed to find/rename files: {failed_renames}")

        return copied_files

    def generate_cmake_config_files(self):
        """为指定的库生成CMake配置文件"""
        logger.info("Generating CMake config files...")

        cmake_dir = Path(self.install_prefix) / "lib" / "cmake"
        cmake_dir.mkdir(parents=True, exist_ok=True)

        generated_configs = []

        for lib_name, config_content in CREATE_LIB_CMAKE_CONFIG.items():
            if config_content.strip():  # 只处理非空配置
                # 为每个库创建子目录
                lib_cmake_dir = cmake_dir / lib_name
                lib_cmake_dir.mkdir(parents=True, exist_ok=True)

                # 生成 Find<LibName>.cmake 文件
                find_config_file = lib_cmake_dir / f"Find{lib_name}.cmake"
                with open(find_config_file, "w") as f:
                    f.write(config_content)

                # 生成 <lib_name>-config.cmake 文件 (标准命名)
                config_file = lib_cmake_dir / f"{lib_name}-config.cmake"
                with open(config_file, "w") as f:
                    f.write(config_content)

                # 生成版本文件 (可选，这里设置一个通用版本)
                version_file = lib_cmake_dir / f"{lib_name}-config-version.cmake"
                version_content = f"""# Generated by kvcache_cxx_packer
# Version file for {lib_name}

set(PACKAGE_VERSION "1.0.0")

# Check whether the requested PACKAGE_FIND_VERSION is compatible
if("${{PACKAGE_VERSION}}" VERSION_LESS "${{PACKAGE_FIND_VERSION}}")
  set(PACKAGE_VERSION_COMPATIBLE FALSE)
else()
  set(PACKAGE_VERSION_COMPATIBLE TRUE)
  if ("${{PACKAGE_VERSION}}" VERSION_EQUAL "${{PACKAGE_FIND_VERSION}}")
    set(PACKAGE_VERSION_EXACT TRUE)
  endif()
endif()
"""
                with open(version_file, "w") as f:
                    f.write(version_content)

                generated_configs.extend([find_config_file, config_file, version_file])
                logger.info(f"Generated CMake config for {lib_name} in {lib_cmake_dir}")

        # 更新CMake模块路径环境变量
        cmake_module_path = str(cmake_dir)
        current_cmake_path = os.environ.get("CMAKE_MODULE_PATH", "")
        if cmake_module_path not in current_cmake_path:
            if current_cmake_path:
                os.environ["CMAKE_MODULE_PATH"] = (
                    f"{current_cmake_path}:{cmake_module_path}"
                )
            else:
                os.environ["CMAKE_MODULE_PATH"] = cmake_module_path

        logger.info(f"Generated {len(generated_configs)} CMake config files")
        return generated_configs

    def clean_cmake_config_files(self):
        """清理之前生成的CMake配置文件，避免在构建时产生冲突"""
        logger.info("Cleaning up previously generated CMake config files...")

        cmake_dir = Path(self.install_prefix) / "lib" / "cmake"
        if not cmake_dir.exists():
            logger.info("No CMake config directory found, skipping cleanup")
            return

        cleaned_files = []

        for lib_name in CREATE_LIB_CMAKE_CONFIG.keys():
            lib_cmake_dir = cmake_dir / lib_name
            if lib_cmake_dir.exists():
                try:
                    # 删除整个库的CMake配置目录
                    shutil.rmtree(lib_cmake_dir)
                    cleaned_files.append(str(lib_cmake_dir))
                    logger.info(
                        f"Cleaned CMake config directory for {lib_name}: {lib_cmake_dir}"
                    )
                except Exception as e:
                    logger.warning(
                        f"Failed to clean CMake config directory for {lib_name}: {e}"
                    )

        # 如果CMAKE_MODULE_PATH环境变量包含了cmake目录，暂时移除它
        current_cmake_path = os.environ.get("CMAKE_MODULE_PATH", "")
        cmake_module_path = str(cmake_dir)
        if cmake_module_path in current_cmake_path:
            # 从环境变量中移除cmake目录路径
            path_parts = current_cmake_path.split(":")
            path_parts = [p for p in path_parts if p != cmake_module_path]
            if path_parts:
                os.environ["CMAKE_MODULE_PATH"] = ":".join(path_parts)
            else:
                os.environ.pop("CMAKE_MODULE_PATH", None)
            logger.info(
                f"Temporarily removed {cmake_module_path} from CMAKE_MODULE_PATH"
            )

        if cleaned_files:
            logger.info(f"Cleaned {len(cleaned_files)} CMake config directories")
        else:
            logger.info("No CMake config files to clean")

        return cleaned_files

    def build_all_packages(self):
        """按依赖顺序构建所有包"""
        logger.info("Starting to build all packages...")

        # 首先安装APT包
        self.install_apt_packages()

        # 设置编译器环境
        self.setup_compiler_environment()

        # 清理之前生成的CMake配置文件，避免在构建时产生冲突
        self.clean_cmake_config_files()

        # 解析依赖顺序
        try:
            build_order = self.resolve_dependencies(PACKS)
            logger.info(
                f"Build order: {[self.get_package_name(url) for url in build_order]}"
            )
        except ValueError as e:
            logger.error(f"Dependency resolution failed: {e}")
            return {}

        # 按顺序构建包（不能并行，因为有依赖关系）
        for url in build_order:
            config = PACKS[url]
            package_name, success, message = self.build_package(url, config)

            self.build_results[package_name] = {
                "url": url,
                "success": success,
                "message": message,
            }

            if not success:
                logger.error(f"Failed to build {package_name}, stopping build process")
                break

        # 复制系统动态库文件到输出目录
        try:
            copied_files = self.copy_dynamic_libraries()
            logger.info(
                f"Dynamic library copy completed, {len(copied_files)} files copied"
            )
        except Exception as e:
            logger.error(f"Failed to copy dynamic libraries: {e}")

        # 生成CMake配置文件
        try:
            generated_configs = self.generate_cmake_config_files()
            logger.info(
                f"CMake config generation completed, {len(generated_configs)} files generated"
            )
        except Exception as e:
            logger.error(f"Failed to generate CMake config files: {e}")

        # 最后更新动态链接器缓存
        self.run_command("ldconfig")

        return self.build_results

    def generate_report(self, output_dir: Path):
        """生成构建报告"""
        output_dir.mkdir(parents=True, exist_ok=True)

        # 生成JSON报告
        report_file = output_dir / "build_report.json"
        with open(report_file, "w") as f:
            json.dump(self.build_results, f, indent=2)

        # 生成文本报告
        text_report = output_dir / "build_report.txt"
        with open(text_report, "w") as f:
            f.write("Build Report\n")
            f.write("=" * 50 + "\n\n")

            successful = 0
            failed = 0

            for package, result in self.build_results.items():
                status = "SUCCESS" if result["success"] else "FAILED"
                f.write(f"{package}: {status}\n")
                f.write(f"  URL: {result['url']}\n")
                f.write(f"  Message: {result['message']}\n\n")

                if result["success"]:
                    successful += 1
                else:
                    failed += 1

            f.write(f"Summary: {successful} successful, {failed} failed\n")

        # 复制日志文件
        if os.path.exists("build.log"):
            shutil.copy("build.log", output_dir / "build.log")

        logger.info(f"Build report generated in {output_dir}")
    
    def clean(self):
        # Clean previous old artifacts.
        shutil.rmtree(self.install_prefix, ignore_errors=True)
        shutil.rmtree(self.build_dir, ignore_errors=True)
        shutil.rmtree(self.output_logs_dir, ignore_errors=True)


def main():
    """主函数"""
    import argparse

    parser = argparse.ArgumentParser(
        description="Build all packages defined in pack.py"
    )
    parser.add_argument(
        "--install-prefix", default="output", help="Installation prefix"
    )
    parser.add_argument("--build-dir", default="build", help="Build directory")
    parser.add_argument(
        "--output-logs-dir", default="output_logs", help="Output directory for reports"
    )
    parser.add_argument(
        "--max-workers", type=int, default=4, help="Maximum parallel workers"
    )

    args = parser.parse_args()

    try:
        # Fix broken installs.
        os.system('apt --fix-broken install')
        
        builder = Builder(
            install_prefix=args.install_prefix,
            build_dir=args.build_dir,
            output_logs_dir=args.output_logs_dir,
            max_workers=args.max_workers,
        )

        # clean before build.
        builder.clean()
        
        results = builder.build_all_packages()
        builder.generate_report(Path(args.output_logs_dir))

        # 打印摘要
        successful = sum(1 for r in results.values() if r["success"])
        total = len(results)

        logger.info(
            f"Build completed: {successful}/{total} packages built successfully"
        )
        
        os.system('tar -zcvf output.tar.gz output')

        if successful == total:
            sys.exit(0)
        else:
            sys.exit(1)

    except Exception as e:
        logger.error(f"Build failed with exception: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
